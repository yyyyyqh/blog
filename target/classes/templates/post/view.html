<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
<head th:replace="layout/base :: head">
    <title th:text="${post.title}">帖子详情</title>
    <style>
        /* 确保 HTML 和 Body 有平滑滚动效果 */
        html {
            scroll-behavior: smooth;
        }

        /* 目录大纲侧边栏容器样式 */
        .toc-sidebar {
            position: sticky;       /* 使用 sticky 定位，以便在滚动时固定 */
            top: 70px;             /* 距离顶部距离，根据您的固定导航栏高度调整 */
            align-self: flex-start;/* 确保在 flex 容器中正确对齐 */
            width: 100%;           /* 宽度将由 Bootstrap 列决定，这里设为100%填充其列 */
            max-height: calc(100vh - 90px); /* 最大高度，预留上下边距 */
            overflow-y: auto;      /* 内容超出时显示垂直滚动条 */
            background-color: #f8f9fa; /* 背景色 (可以调整为 #fff 或其他) */
            border: 1px solid #dee2e6;  /* 边框 */
            padding: 15px;         /* 内边距 */
            border-radius: .25rem;     /* 圆角 */
            box-shadow: 0 1px 3px rgba(0,0,0,0.05); /* 轻微阴影 */
        }

        .toc-sidebar h5 {
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        /* 目录列表整体样式 */
        .toc-sidebar ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        /* 目录列表项样式 */
        .toc-sidebar li {
            margin-bottom: 5px;
            line-height: 1.5;
        }

        /* 多级列表缩进和样式 */
        .toc-sidebar ul ul {
            padding-left: 15px;   /* 左侧缩进 */
            margin-top: 5px;
        }
        .toc-sidebar ul ul ul { padding-left: 15px; margin-top: 5px; }
        .toc-sidebar ul ul ul ul { padding-left: 15px; margin-top: 5px; }
        .toc-sidebar ul ul ul ul ul { padding-left: 15px; margin-top: 5px; }


        /* 目录链接样式 */
        .toc-sidebar a {
            text-decoration: none;
            color: #495057;        /* 链接颜色 */
            display: block;
            font-size: 0.875em;     /* 字体大小 */
            white-space: normal;
            word-break: break-word;
            padding: .25rem .5rem; /* 链接内边距 */
            border-radius: .2rem;
            border-left: 3px solid transparent; /* 左侧高亮边框的占位 */
        }

        /* 鼠标悬停时的链接样式 */
        .toc-sidebar a:hover {
            color: #007bff;
            background-color: #e9ecef;
        }

        /* 高亮时的目录链接样式 (由 JavaScript 添加 'active' 类) */
        .toc-sidebar a.active {
            font-weight: bold;
            color: #007bff;
            border-left-color: #007bff;
            background-color: #ddeeff;
        }

        /* 响应式调整 (处理小屏幕时的布局) */
        /* Bootstrap的列系统 (col-lg-*, col-md-*) 应该会自动处理堆叠。
           这里的 @media query 是从您的示例中带来的，主要用于调整 .toc-sidebar 的固定行为。
           如果Bootstrap列不能满足，可以取消注释并调整。
        */
        @media (max-width: 991.98px) { /* Bootstrap lg 断点以下 */
            .toc-sidebar {
                position: static; /* 取消固定/粘性定位，恢复正常文档流 */
                width: auto;
                max-height: none;
                margin-top: 20px;
            }
            /* 主内容列和目录列在中小屏幕下会自然堆叠成100%宽度，无需额外CSS */
        }
    </style>
</head>
<body>
    <div th:replace="layout/base :: nav"></div>

    <div class="container mt-4">
        <div class="row">
            <div class="col-lg-9 col-md-8">
                <nav aria-label="breadcrumb">
                    <ol class="breadcrumb">
                        <li class="breadcrumb-item"><a th:href="@{/post}">帖子列表</a></li>
                        <li class="breadcrumb-item active" th:text="${post.title}"></li>
                    </ol>
                </nav>

                <div class="card mb-4">
                    <div class="card-body">
                        <h2 class="card-title" th:text="${post.title}"></h2>
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <div>
                                <small class="text-muted">
                                    作者：<span th:text="${post.author.username}"></span>
                                </small>
                                <small class="text-muted ms-3">
                                    发布时间：<span th:text="${#temporals.format(post.createdAt, 'yyyy-MM-dd HH:mm')}"></span>
                                </small>
                            </div>
                            <div>
                                <small class="text-muted">
                                    浏览：<span th:text="${post.viewCount}"></span>
                                </small>
                            </div>
                        </div>
                        <div class="card-text" id="post-article-content" th:utext="${postHtmlContent}">
                        </div>

                        <div class="mt-3" sec:authorize="isAuthenticated() and #authentication.name == #vars.post.author.username">
                            <a th:href="@{/post/{id}/edit(id=${post.id})}" class="btn btn-primary btn-sm">编辑</a>
                            <form th:action="@{/post/{id}/delete(id=${post.id})}" method="post" class="d-inline">
                                <button type="submit" class="btn btn-danger btn-sm"
                                        onclick="return confirm('确定要删除这篇帖子吗？\n此操作不可撤销！')">删除</button>
                            </form>
                        </div>
                    </div>
                </div>

                <div class="card mt-4">
                    <div class="card-header">
                        <h5 class="mb-0">评论</h5>
                    </div>
                    <div class="card-body">
                        <div sec:authorize="isAuthenticated()">
                            <form th:action="@{/comment/create}" method="post">
                                <input type="hidden" name="postId" th:value="${post.id}">
                                <div class="mb-3">
                                    <textarea class="form-control" name="content" rows="3" required placeholder="写下你的评论..."></textarea>
                                </div>
                                <button type="submit" class="btn btn-primary">发表评论</button>
                            </form>
                        </div>
                        <div sec:authorize="!isAuthenticated()" class="alert alert-info">
                            请<a th:href="@{/user/login}">登录</a>后发表评论
                        </div>

                        <div class="mt-4">
                            <div th:each="comment : ${comments}" class="card mb-3">
                                <div class="card-body">
                                    <div class="d-flex justify-content-between">
                                        <div>
                                            <strong th:text="${comment.author.username}"></strong>
                                            <small class="text-muted ms-2" th:text="${#temporals.format(comment.createdAt, 'yyyy-MM-dd HH:mm')}"></small>
                                        </div>
                                        <div sec:authorize="isAuthenticated() and #authentication.name == #vars.comment.author.username">
                                            <button class="btn btn-link btn-sm text-decoration-none"
                                                    th:onclick="'editComment(' + ${comment.id} + ')'">编辑</button>
                                            <form th:action="@{/comment/{id}/delete(id=${comment.id})}" method="post" class="d-inline">
                                                <input type="hidden" name="postId" th:value="${post.id}">
                                                <button type="submit" class="btn btn-link btn-sm text-danger text-decoration-none"
                                                        onclick="return confirm('确定要删除这条评论吗？\n此操作不可撤销！')">删除</button>
                                            </form>
                                        </div>
                                    </div>
                                    <p class="card-text mt-2" th:text="${comment.content}"></p>
                                </div>
                            </div>
                            <div th:if="${comments == null or comments.isEmpty()}"> <p>暂无评论，快来发表第一条评论吧！</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-lg-3 col-md-4 d-none d-lg-block">
                <div class="toc-sidebar" id="table-of-contents-container">
                    <h5 class="pt-0">文章目录</h5>
                    <ul id="toc-list-ul"></ul>
                </div>
            </div>
        </div>
    </div>

    <div th:replace="layout/base :: footer"></div>

    <script th:inline="javascript" th:if="${post != null}">
        // 编辑评论的 JavaScript 函数
        function editComment(commentId) {
            const newContent = prompt('请输入新的评论内容：', ''); // 第二个参数是默认值
            if (newContent !== null && newContent.trim() !== '') { // 检查用户是否输入了内容且不是仅空白
                const form = document.createElement('form');
                form.method = 'POST';
                form.action = /*[[@{/comment/}]]*/ '' + commentId + '/edit'; // Thymeleaf URL

                const contentInput = document.createElement('input');
                contentInput.type = 'hidden';
                contentInput.name = 'content';
                contentInput.value = newContent;

                const postIdInput = document.createElement('input');
                postIdInput.type = 'hidden';
                postIdInput.name = 'postId';
                postIdInput.value = /*[[${post.id}]]*/ '';

                form.appendChild(contentInput);
                form.appendChild(postIdInput);
                document.body.appendChild(form);
                form.submit();
            } else if (newContent !== null) { // 用户点击了确定但没输入内容
                alert('评论内容不能为空！');
            }
        }
    </script>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            const contentElement = document.getElementById('post-article-content');
            const tocRootUlElement = document.getElementById('toc-list-ul');
            const tocNavContainer = document.getElementById('table-of-contents-container');

            const mainContentColumn = document.querySelector('.col-lg-9.col-md-8'); // 主内容列
            const tocColumnElement = document.querySelector('.col-lg-3.col-md-4');   // 目录列

            if (!contentElement || !tocRootUlElement || !tocNavContainer || !mainContentColumn || !tocColumnElement) {
                console.warn('TOC critical elements not found. Skipping TOC generation and hiding TOC column.');
                if(tocNavContainer) tocNavContainer.style.display = 'none';
                if(tocColumnElement) tocColumnElement.style.display = 'none';
                if(mainContentColumn) { // 如果目录列不存在或隐藏，主内容列扩展
                    mainContentColumn.classList.remove('col-lg-9', 'col-md-8');
                    mainContentColumn.classList.add('col-lg-12', 'col-md-12'); // 扩展到全宽
                }
                return;
            }

            const headingSelectors = '#post-article-content h1, #post-article-content h2, #post-article-content h3, #post-article-content h4, #post-article-content h5, #post-article-content h6';
            const headings = Array.from(document.querySelectorAll(headingSelectors));

            if (headings.length === 0) {
                if (tocNavContainer) tocNavContainer.style.display = 'none';
                if (tocColumnElement) tocColumnElement.style.display = 'none';
                if (mainContentColumn) {
                    mainContentColumn.classList.remove('col-lg-9', 'col-md-8');
                    mainContentColumn.classList.add('col-lg-12', 'col-md-12');
                }
                return;
            }

            const listStack = [tocRootUlElement]; // 栈来管理当前嵌套的ul

            headings.forEach(function(heading) {
                const id = heading.id;
                const text = heading.textContent.trim();
                const level = parseInt(heading.tagName.substring(1)); // h1 -> 1, h2 -> 2

                if (!id || !text) {
                    console.warn('Skipping heading without ID or text:', heading.outerHTML);
                    return;
                }

                // 根据级别调整列表嵌套
                // listStack 的长度代表当前所在的嵌套深度 (根ul算第1层)
                while (level > listStack.length) { // 需要更深的嵌套
                    const parentLi = listStack[listStack.length - 1].lastElementChild;
                    if (!parentLi) { // 如果父ul还没有li (理论上不应发生，除非是空的h(x-1))
                        // 创建一个临时的父级li，这种情况比较罕见，通常每个ul都始于一个li
                        const tempParentLi = document.createElement('li');
                        listStack[listStack.length - 1].appendChild(tempParentLi);
                        const newUl = document.createElement('ul');
                        tempParentLi.appendChild(newUl);
                        listStack.push(newUl);
                    } else {
                        const newUl = document.createElement('ul');
                        parentLi.appendChild(newUl);
                        listStack.push(newUl);
                    }
                }
                while (level < listStack.length) { // 需要返回到上层嵌套
                    listStack.pop();
                }

                const currentList = listStack[listStack.length - 1];
                const listItem = document.createElement('li');
                const link = document.createElement('a');
                link.href = '#' + id;
                link.textContent = text;

                listItem.appendChild(link);
                currentList.appendChild(listItem);
            });

            // --- Scrollspy JS ---
            const contentHeadingsForScrollspy = headings; // 我们已经获取了headings
            const tocLinksForScrollspy = document.querySelectorAll('.toc-sidebar ul a');
            const scrollSpyOffset = 80; // 偏移量，根据您的固定导航栏高度调整

            let currentlyActiveLink = null; // 用于存储当前高亮的链接元素

            function highlightTocLink() {
                let newActiveHeadingId = null;
                let bestMatch = { id: null, top: Infinity }; // 用来找最接近offset的标题

                for (let i = 0; i < contentHeadingsForScrollspy.length; i++) {
                    const heading = contentHeadingsForScrollspy[i];
                    const rect = heading.getBoundingClientRect();

                    // 条件1: 标题的上边缘在偏移量下方，或者标题的下边缘在偏移量上方但标题仍在视口内
                    //       这意味着标题的“主体”部分正在或即将通过偏移线附近
                    if (rect.top <= scrollSpyOffset && rect.bottom > scrollSpyOffset / 3) { // 放宽一点底部判断
                        // 如果多个标题满足，我们通常希望高亮最接近偏移线的那个
                        // （即 rect.top 最接近 scrollSpyOffset 且不大于它的那个）
                        // 或者简单地，从上往下第一个顶部低于offset的
                        if (rect.top < bestMatch.top && rect.top <= scrollSpyOffset) { // 更新：找rect.top最接近offset且不大于它的
                            // 如果我们想要的是 "当前屏幕主要显示的段落对应的标题"
                            // 而不是 "刚刚滚过去的标题"
                            // 那么当标题的 rect.top > 0 并且 rect.top < offset 时，它是很好的候选
                            // 简单起见，我们还是用第一个顶部低于offset的标题
                            newActiveHeadingId = heading.id;
                            break; // 从上往下，第一个顶部低于offset的就激活它
                        }
                    }
                }

                // 如果没有找到新的激活标题（可能在两个标题之间的大段空白，或已滚过所有标题）
                // 并且页面不是在最顶部，我们尝试保持之前的高亮
                if (!newActiveHeadingId && window.scrollY > 0) {
                    // 如果之前有高亮的链接，则保持它，除非有新的有效高亮
                    if (currentlyActiveLink) {
                        // 这里我们什么都不做，让 currentlyActiveLink 保持 active 状态
                        // 但是，如果滚动到了最底部，最后一个标题也已经滚过去了，
                        // 这种情况下可能希望最后一个目录项保持高亮。
                        const lastHeading = contentHeadingsForScrollspy[contentHeadingsForScrollspy.length - 1];
                        if (lastHeading && lastHeading.getBoundingClientRect().bottom < scrollSpyOffset) {
                            newActiveHeadingId = lastHeading.id; // 强制高亮最后一个
                        } else {
                            return; // 没有新的激活项，也不满足特殊条件，则不改变当前高亮
                        }
                    } else if (contentHeadingsForScrollspy.length > 0) {
                        // 如果之前没有高亮，且不在顶部，可能处于初始加载后的滚动，尝试高亮第一个
                        // newActiveHeadingId = contentHeadingsForScrollspy[0].id;
                    }
                } else if (!newActiveHeadingId && window.scrollY === 0 && tocLinksForScrollspy.length > 0) {
                    // 滚动到页面最顶部，高亮第一个目录项
                    newActiveHeadingId = contentHeadingsForScrollspy[0] ? contentHeadingsForScrollspy[0].id : null;
                }


                // 如果新的激活ID与当前的不同，或者当前没有激活的链接，则更新高亮
                const newActiveLink = newActiveHeadingId ? document.querySelector(`.toc-sidebar a[href="#${CSS.escape(newActiveHeadingId)}"]`) : null;

                if (newActiveLink !== currentlyActiveLink) {
                    if (currentlyActiveLink) {
                        currentlyActiveLink.classList.remove('active');
                    }
                    if (newActiveLink) {
                        newActiveLink.classList.add('active');
                        // 可选: 将激活的目录项滚动到目录侧边栏的可见区域
                        // newActiveLink.scrollIntoView({ behavior: 'auto', block: 'nearest', inline: 'nearest' });
                    }
                    currentlyActiveLink = newActiveLink;
                }
            }

            // (window.addEventListener 和初始调用 highlightTocLink() 保持不变)
            if (contentHeadingsForScrollspy.length > 0 && tocLinksForScrollspy.length > 0) {
                window.addEventListener('scroll', highlightTocLink, { passive: true });
                highlightTocLink(); // 初始高亮
            }
        });
    </script>
</body>
</html>